// Copyright 2021 Datafuse Labs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::collections::BTreeMap;
use std::collections::HashMap;
use std::hash::{DefaultHasher, Hasher};
use std::ops::{ControlFlow, Deref};
use std::sync::Arc;
use parquet::data_type::AsBytes;
use databend_common_exception::ErrorCode;
use databend_common_exception::Result;
use databend_common_expression::{eval_function, generate_like_pattern, BlockEntry, ConstantFolder, Domain, LikePattern, TableSchema};
use databend_common_expression::types::{AnyType, Bitmap};
use databend_common_expression::types::Buffer;
use databend_common_expression::types::DataType;
use databend_common_expression::types::NullableColumn;
use databend_common_expression::types::NullableType;
use databend_common_expression::types::NumberDataType;
use databend_common_expression::types::NumberScalar;
use databend_common_expression::types::StringColumn;
use databend_common_expression::types::StringType;
use databend_common_expression::types::UInt32Type;
use databend_common_expression::types::UInt64Type;
use databend_common_expression::types::ValueType;
use databend_common_expression::Column;
use databend_common_expression::DataBlock;
use databend_common_expression::Expr;
use databend_common_expression::FieldIndex;
use databend_common_expression::FunctionContext;
use databend_common_expression::Scalar;
use databend_common_expression::ScalarRef;
use databend_common_expression::TableDataType;
use databend_common_expression::TableField;
use databend_common_expression::TableSchemaRef;
use databend_common_expression::Value;
use databend_common_functions::BUILTIN_FUNCTIONS;
use databend_storages_common_table_meta::meta::StatisticsOfColumns;
use databend_storages_common_table_meta::meta::Versioned;
use parquet::format::FileMetaData;
use tantivy::tokenizer::{LowerCaser, SimpleTokenizer, TextAnalyzer, TokenStream, TokenizerManager};
use databend_common_ast::Span;
use databend_common_expression::types::boolean::BooleanDomain;
use databend_common_expression::types::nullable::NullableDomain;
use databend_common_functions::scalars::DFHash;
use crate::bloom_index::{domain, visit_expr_column_eq_constant, EqVisitor, ResultRewrite, ShortListVisitor};
use crate::filters::BlockBloomFilterIndexVersion;
use crate::filters::BlockFilter;
use crate::filters::Filter;
use crate::filters::FilterBuilder;
use crate::filters::Xor8Builder;
use crate::filters::Xor8Filter;
use crate::BloomIndex;
use crate::BloomIndexMeta;
use crate::FilterEvalResult;

#[derive(Clone)]
pub struct NgramIndexMeta {
    pub inner: BloomIndexMeta,
}

impl TryFrom<FileMetaData> for NgramIndexMeta {
    type Error = databend_common_exception::ErrorCode;

    fn try_from(meta: FileMetaData) -> std::result::Result<Self, Self::Error> {
        Ok(NgramIndexMeta {
            inner: BloomIndexMeta::try_from(meta)?,
        })
    }
}

pub struct NgramIndex {
    pub func_ctx: FunctionContext,

    /// The schema of the filter block.
    ///
    /// It is a sub set of the source table's schema.
    pub filter_schema: TableSchemaRef,

    ///  filters.
    pub filters: Vec<Arc<Xor8Filter>>,

    /// Approximate distinct count of columns generated by xor hash function.
    pub column_distinct_count: HashMap<FieldIndex, usize>,

    pub n: u32,
}

impl NgramIndex {
    pub fn from_filter_block(
        func_ctx: FunctionContext,
        filter_schema: TableSchemaRef,
        filters: Vec<Arc<Xor8Filter>>,
        n: u32,
    ) -> Result<Self> {
        Ok(Self {
            func_ctx,
            filter_schema,
            filters,
            column_distinct_count: HashMap::new(),
            n,
        })
    }

    pub fn try_create(
        func_ctx: FunctionContext,
        block: &DataBlock,
        bloom_columns_map: BTreeMap<FieldIndex, TableField>,
        n: u32,
    ) -> Result<Option<Self>> {
        if block.is_empty() {
            return Err(ErrorCode::BadArguments("block is empty"));
        }

        if block.num_columns() == 0 {
            return Ok(None);
        }

        let mut filter_fields = vec![];
        let mut filters = vec![];
        let mut column_distinct_count = HashMap::<usize, usize>::new();
        for (index, field) in bloom_columns_map {
            let column = match &block.get_by_offset(index).value {
                Value::Scalar(_) => continue,
                Value::Column(c) => match c {
                    Column::Nullable(v) if v.validity.true_count() == 0 => continue,
                    Column::Null { .. } => continue,
                    _ => c.clone(),
                },
            };
            let data_type = &block.get_by_offset(index).data_type;
            if !matches!(data_type.remove_nullable(), DataType::String) {
                continue;
            }
            if BloomIndex::check_large_string(&column) {
                continue;
            }

            // for column_distinct_count
            {
                let filter = BloomIndex::build_filter(&func_ctx, &column, &data_type)?;

                if let Some(len) = filter.len() {
                    column_distinct_count.insert(index, len);
                    // Not need to generate bloom index,
                    // it will never be used since range index is checked first.
                    if len < 2 {
                        continue;
                    }
                }
            }

            // create filter per column
            let mut filter_builder = Xor8Builder::create();
            for ngram_digests in
                Self::calculate_nullable_column_digest(&func_ctx, Value::Column(column), data_type, n)?
            {
                filter_builder.add_digests(ngram_digests.deref())
            }
            let filter = filter_builder.build()?;
            if let Some(len) = filter.len() {
                // Not need to generate bloom index,
                // it will never be used since range index is checked first.
                if len < 2 {
                    continue;
                }
            }

            filter_fields.push(TableField::new(
                &Self::build_filter_column_name(&field),
                TableDataType::Binary,
            ));
            filters.push(Arc::new(filter));
        }

        if filter_fields.is_empty() {
            return Ok(None);
        }

        let filter_schema = Arc::new(TableSchema::new(filter_fields));

        Ok(Some(Self {
            func_ctx,
            filter_schema,
            filters,
            column_distinct_count,
            n,
        }))
    }

    pub fn calculate_nullable_column_digest<'a>(
        func_ctx: &'a FunctionContext,
        arg: Value<AnyType>,
        data_type: &'a DataType,
        n: u32,
    ) -> Result<impl Iterator<Item=Buffer<u64>> + 'a> {
        let arg_len = arg.len();
        let (value, _) = eval_function(
            None,
            "ngram_then_hash",
            [
                (arg, data_type.clone()),
                (
                    Value::Scalar(Scalar::Number(NumberScalar::UInt32(n))),
                    DataType::Number(NumberDataType::UInt32),
                ),
            ],
            func_ctx,
            arg_len,
            &BUILTIN_FUNCTIONS,
        )?;

        Ok((0..value.len()).into_iter().filter_map(move |i| {
            value.index(i).and_then(|scalar| {
                if let ScalarRef::Array(column) = scalar {
                    return Some(UInt64Type::try_downcast_column(&column).unwrap());
                }
                None
            })
        }))
    }

    #[expect(clippy::type_complexity)]
    pub fn filter_index_field(
        mut expr: Expr<String>,
        fields: &[TableField],
    ) -> Result<(Vec<TableField>, Vec<(Scalar, DataType)>)> {
        let mut visitor = ShortListVisitor {
            fields: fields.to_vec(),
            founds: Vec::new(),
            scalars: Vec::new(),
        };
        visit_expr_column_like_constant(&mut expr, &mut visitor)?;
        let ShortListVisitor {
            founds, scalars, ..
        } = visitor;
        Ok((founds, scalars))
    }

    pub fn build_filter_column_name(field: &TableField) -> String {
        format!("Ngram({})", field.column_id())
    }

    fn find(
        &self,
        filter_column: &str,
        target: &Scalar,
        ty: &DataType,
        scalar_map: &HashMap<Scalar, Buffer<u64>>,
    ) -> Result<FilterEvalResult> {
        if !self.filter_schema.has_field(filter_column)
            || !matches!(ty.remove_nullable(), DataType::String)
            || target.is_null()
        {
            // The column doesn't have a filter.
            return Ok(FilterEvalResult::Uncertain);
        }

        let idx = self.filter_schema.index_of(filter_column)?;
        let filter = &self.filters[idx];

        let contains = scalar_map
            .get(target)
            .map_or(true, |digests| {
                digests.iter().all(|digest| filter.contains_digest(*digest))
            });
        if contains {
            Ok(FilterEvalResult::Uncertain)
        } else {
            Ok(FilterEvalResult::MustFalse)
        }
    }

    pub fn serialize_to_data_block(&self) -> Result<DataBlock> {
        let fields = self.filter_schema.fields();
        let mut filter_columns = Vec::with_capacity(fields.len());
        for filter in &self.filters {
            let serialized_bytes = filter.to_bytes()?;
            let filter_value = Value::Scalar(Scalar::Binary(serialized_bytes));
            filter_columns.push(BlockEntry::new(DataType::Binary, filter_value));
        }
        Ok(DataBlock::new(filter_columns, 1))
    }

    #[fastrace::trace]
    pub fn apply(
        &self,
        expr: Expr<String>,
        scalar_map: &HashMap<Scalar, Buffer<u64>>,
        column_stats: &StatisticsOfColumns,
        data_schema: TableSchemaRef,
    ) -> Result<FilterEvalResult> {
        let (expr, domains) = self.rewrite_expr(expr, scalar_map, column_stats, data_schema)?;
        match ConstantFolder::fold_with_domain(&expr, &domains, &self.func_ctx, &BUILTIN_FUNCTIONS)
            .0
        {
            Expr::Constant {
                scalar: Scalar::Boolean(false),
                ..
            } => Ok(FilterEvalResult::MustFalse),
            _ => Ok(FilterEvalResult::Uncertain),
        }
    }

    pub fn rewrite_expr(
        &self,
        mut expr: Expr<String>,
        scalar_map: &HashMap<Scalar, Buffer<u64>>,
        column_stats: &StatisticsOfColumns,
        data_schema: TableSchemaRef,
    ) -> Result<(Expr<String>, HashMap<String, Domain>)> {
        let mut domains = BloomIndex::rewirte_expr_domains(&mut expr, column_stats, &data_schema);

        let mut visitor = RewriteVisitor {
            new_col_id: 1,
            index: self,
            data_schema,
            scalar_map,
            column_stats,
            domains: &mut domains,
        };

        visit_expr_column_like_constant(&mut expr, &mut visitor)?;

        Ok((expr, domains))
    }
}

struct RewriteVisitor<'a> {
    new_col_id: usize,
    index: &'a NgramIndex,
    data_schema: TableSchemaRef,
    scalar_map: &'a HashMap<Scalar, Buffer<u64>>,
    column_stats: &'a StatisticsOfColumns,
    domains: &'a mut HashMap<String, Domain>,
}

impl EqVisitor for RewriteVisitor<'_> {
    fn enter_target(&mut self, span: Span, col_name: &str, scalar: &Scalar, ty: &DataType, return_type: &DataType) -> crate::bloom_index::ResultRewrite {
        let filter_column = NgramIndex::build_filter_column_name(self.data_schema.field_with_name(col_name)?);

        // If the column doesn't contain the constant,
        // we rewrite the expression to a new column with `false` domain.
        if self
            .index
            .find(&filter_column, scalar, ty, self.scalar_map)?
            != FilterEvalResult::MustFalse
        {
            return Ok(ControlFlow::Break(None));
        }
        let new_col_name = format!("__ngram_column_{}_{}", col_name, self.new_col_id);
        self.new_col_id += 1;
        let bool_domain = Domain::Boolean(BooleanDomain {
            has_false: true,
            has_true: false,
        });
        let new_domain = domain(&self.data_schema, self.column_stats, col_name, return_type, bool_domain);
        self.domains.insert(new_col_name.clone(), new_domain);

        Ok(ControlFlow::Break(Some(Expr::ColumnRef {
            span,
            id: new_col_name.clone(),
            data_type: return_type.clone(),
            display_name: new_col_name,
        })))
    }
}

pub(crate) fn visit_expr_column_like_constant(
    expr: &mut Expr<String>,
    visitor: &mut impl EqVisitor,
) -> Result<()> {
    // TODO: maybe we can support the case of `and` & `or`
    match match expr {
        Expr::FunctionCall {
            id,
            args,
            ..
        } if id.name() == "is_true" => {
            return visit_expr_column_like_constant(&mut args[0], visitor);
        }
        Expr::FunctionCall {
            span,
            id,
            args,
            return_type,
            ..
        } if id.name() == "like" => match args.as_slice() {
            // patterns like `Column = <constant>`, `<constant> = Column`
            [Expr::ColumnRef {
                id,
                data_type: column_type,
                ..
            }, Expr::Constant {
                scalar,
                data_type: scalar_type,
                ..
            }]
            | [Expr::Constant {
                scalar,
                data_type: scalar_type,
                ..
            }, Expr::ColumnRef {
                id,
                data_type: column_type,
                ..
            }] => {
                let mut res = ControlFlow::Continue(None);
                if let Some(pattern) = scalar.as_string() {
                    if let LikePattern::SurroundByPercent(v) = generate_like_pattern(pattern.as_bytes(), 1) {
                        let string = String::from_utf8_lossy(v.needle().as_bytes()).to_string();

                        res = visitor.enter_target(*span, id, &Scalar::String(string), column_type, return_type)?;
                    }
                }
                res
            }
            _ => ControlFlow::Continue(None),
        },
        _ => ControlFlow::Continue(None),
    } {
        ControlFlow::Break(Some(new_expr)) => {
            *expr = new_expr;
        }
        ControlFlow::Continue(_) | ControlFlow::Break(None) => (),
    }
    Ok(())
}
